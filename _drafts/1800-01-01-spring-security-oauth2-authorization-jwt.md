---
layout: post

title:  "Spring Cloud Security - OAuth2 Authorization using JWT (Java Web Token)"
description:  "Spring Cloud Security - OAuth2 Authorization using JWT (Java Web Token)"

permalink: "/spring-cloud-security/oauth2-authorization-jwt"

date: "2019-12-29"
last_modified_at: "2019-12-30"

categories: [Spring Cloud,Spring Cloud Security]

github:
  repository_url: https://github.com/codeaches/jwt-oauth2-authorization-and-resource-servers
  badges: [download]

postman:
  collections_url: https://documenter.getpostman.com/view/9215681/SWLbAq2F?version=latest
---

**Oauth2** is a widely used authorization framework and is supported by Spring. The Spring OAuth 2.0 Authorization mechanism manages and verifies the OAuth 2.0 tokens. These tokens are then used to access the protected resources.

Without going much into theory, let's assume a real world security problem statement and see how we can accomplish our desired solution using JDBC OAuth2 security features provided by Spring.<!-- excerpt end -->

### **What you’ll get out of this guide**

After reading this guide, you will have a Spring Boot OAuth2 application ...TODO

And with that, let’s get started!

**As part of this tutorial, let's build a basic REST service - Car Inventory Service**.

- _Car Inventory Service_ shall have two methods - **getCars()** and **addCar()**.

We are also entrusted to protect our services by giving access to only those who need them. 

Let's have 2 users **John** and **Kelly**. 
- **John** needs access to both **getCars()** and **addCar()**
- **Kelly** needs access to **getCars()**

>_Above scenario is a typical authentication and authorization scenario where we are supposed to authenticate the user and check if the authenticated user is authorized to access the resources/services._


To achieve the above Auth mechanism, we shall build another spring boot service which will be our **Spring OAuth2 Authorization server**. 
We shall configure this service to hold user credentials of **John**, **Kelly** and also the authorization details for our **Car Inventory Service**.

### **Spring OAuth2 Authorization server**

Building the bare bone Spring OAuth2 Authorization server is simple - Create a spring boop application and annotate the main class with `@EnableAuthorizationServer` annotation. Let's start off with that.

**Create a Spring Boot starter project using Spring Initializr**

Let's utilize the spring initializr starter tool to create the **Spring OAuth2 Authorization server**.

```sh
curl --request GET https://start.spring.io/starter.zip  \
     --data dependencies=web,cloud-security,cloud-oauth2,h2,data-jpa \
     --data language=java \
     --data javaVersion=12 \
     --data type=maven-project \
     --data groupId=com.codeaches \
     --data artifactId=jwt-oauth2-server \
     --data bootVersion=2.1.5.RELEASE \
     --output jwt-oauth2-server.zip
```

> The above command will give us a spring boot starter project. Import the project to your IDE.


**Add JWT dependency to OAuth2 Authorization server**

```xml
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-jwt</artifactId>
    <version>1.0.10.RELEASE</version>
</dependency>
```

**Create tables for users, groups, group authorities and group members**

Let's create tables to hold the users and groups details in embedded h2 db by providing the DDL scripts which runs during server startup. These are standard DDL scripts for H2 DB provided by Spring Oauth2 framework.

`src/main/resources/schema.sql`

```sql
drop table users if exists;
create table users(
    username varchar_ignorecase(256) not null primary key,
    password varchar_ignorecase(256) not null,
    enabled boolean not null
);

drop table groups if exists;
create table groups (
    id bigint generated by default as identity(start with 0) primary key,
    group_name varchar_ignorecase(50) not null
);

drop table group_authorities if exists;
create table group_authorities (
    group_id bigint not null,
    authority varchar(50) not null,
    constraint fk_group_authorities_group foreign key(group_id) references groups(id)
);

drop table group_members if exists;
create table group_members (
    id bigint generated by default as identity(start with 0) primary key,
    username varchar(50) not null,
    group_id bigint not null,
    constraint fk_group_members_group foreign key(group_id) references groups(id)
);
```

**Add users, groups, group authorities and group members**

- Let's create users named **john** with a password **john@123** and **kelly** with a password **kelly@123**  
- Create a group **INVENTORY_GROUP_1** and assign the roles _INVENTORY_VIEW_ and **INVENTORY_ADD**
- Similarly create a group **INVENTORY_GROUP_2** with role **INVENTORY_VIEW**
- Add _john_ to group **INVENTORY_GROUP_1** and _kelly_ to group **INVENTORY_GROUP_2**

> The password needs to be saved to DB in Bcrypt format. I have used an online tool to Bcrypt the password with 4 rounds.  

`src/main/resources/data.sql`

```sql
INSERT INTO users (username,password,enabled) 
    VALUES ('john', '$2a$04$Ts1ry6sOr1BXXie5Eez.j.bsvqC0u3x7xAwOInn2qrItwsUUIC9li', TRUE);
INSERT INTO users (username,password,enabled) 
    VALUES ('kelly','$2a$04$qkCGgz.e5dkTiZogvzxla.KXbIvWXrQzyf8wTPJOOJBKjtHAQhoBa', TRUE);
  
INSERT INTO groups (id, group_name) VALUES (1, 'INVENTORY_GROUP_1');
INSERT INTO groups (id, group_name) VALUES (2, 'INVENTORY_GROUP_2');

INSERT INTO group_authorities (group_id, authority) VALUES (1, 'INVENTORY_VIEW');
INSERT INTO group_authorities (group_id, authority) VALUES (1, 'INVENTORY_ADD');

INSERT INTO group_authorities (group_id, authority) VALUES (2, 'INVENTORY_VIEW');

INSERT INTO group_members (username, group_id) VALUES ('john', 1);
INSERT INTO group_members (username, group_id) VALUES ('kelly', 2);
```

**Create tables for clients, users and groups**

Now, let's to create tables to hold the user credentials, user access details for each of the services/resources. These are standard DDLs provided by Spring. We shall create a schema file and save the DDLs.

Create `src/main/resources/schema.sql` file with below DDLs.

```sql
drop table oauth_client_details if exists;
create table oauth_client_details (
    client_id varchar(256) primary key,
    resource_ids varchar(256),
    client_secret varchar(256),
    scope varchar(256),
    authorized_grant_types varchar(256),
    web_server_redirect_uri varchar(256),
    authorities varchar(256),
    access_token_validity integer,
    refresh_token_validity integer,
    additional_information varchar(4096),
    autoapprove varchar(256)
);

drop table oauth_access_token if exists;
create table oauth_access_token (
  token_id VARCHAR(256),
  token LONGVARBINARY,
  authentication_id VARCHAR(256) PRIMARY KEY,
  user_name VARCHAR(256),
  client_id VARCHAR(256),
  authentication LONGVARBINARY,
  refresh_token VARCHAR(256)
);

drop table oauth_refresh_token if exists;
create table oauth_refresh_token (
  token_id VARCHAR(256),
  token LONGVARBINARY,
  authentication LONGVARBINARY
);
```

> `oauth_client_details` table is used to store client details.  
> `oauth_access_token` and `oauth_refresh_token` is used internally by OAuth2 server to store the access and refresh tokens.

**Create a client**

Let's insert a record in `oauth_client_details` table for a client named `appclient` with a password `appclient@123`.  
> **appclient** has access to the **carInventory** resource.
> The password needs to be saved to DB in Bcrypt format. I have used an online tool to Bcrypt the password with 8 rounds. 

`src/main/resources/data.sql`

```sql
INSERT INTO
  oauth_client_details (
    client_id,
    client_secret,
    resource_ids,
    scope,
    authorized_grant_types,
    access_token_validity,
    refresh_token_validity
  )
VALUES
  (
    'appclient',
    '$2a$08$dKyJRiySVD6wP.TElU52kOdkBq.8qId0o8KjwJqIEE5PjkwZQUoWu',
    'carInventory',
    'read,write',
    'authorization_code,check_token,refresh_token,password',
    25000,
    500000
  );
```

**Configure OAuth2 Server**

Let's create a class `AuthServerConfig.java` and annotate with `@EnableAuthorizationServer`. This annotation is used by spring internally to configure the OAuth 2.0 Authorization Server mechanism

- **JwtAccessTokenConverter** is a helper class that translates between JWT encoded token values and OAuth authentication information (in both directions). It also acts as a TokenEnhancer when tokens are granted.   
- **BCryptPasswordEncoder** implements PasswordEncoder that uses the BCrypt strong hashing function. Clients can optionally supply a "strength" (a.k.a. log rounds in BCrypt) and a SecureRandom instance. The larger the strength parameter the more work will have to be done (exponentially) to hash the passwords. The value used in this example is 8 for `client secret`.    
- **AuthorizationServerEndpointsConfigurer** configures the non-security features of the Authorization Server endpoints, like token store, token customizations, user approvals and grant types.    
- **AuthorizationServerSecurityConfigurer** configures the security of the Authorization Server, which means in practical terms the **/oauth/token**endpoint.    
- **ClientDetailsServiceConfigurer** configures the ClientDetailsService, e.g. declaring individual clients and their properties.

`com.codeaches.jwtoauth2server.AuthServerConfig.java`

```java
@Configuration
@EnableAuthorizationServer
public class AuthServerConfig extends AuthorizationServerConfigurerAdapter {

    @Autowired
    DataSource ds;

    @Autowired
    AuthenticationManager authMgr;

    @Autowired
    private UserDetailsService usrSvc;

    @Bean("clientPasswordEncoder")
    PasswordEncoder clientPasswordEncoder() {
        return new BCryptPasswordEncoder(8);
    }

    @Bean
    JwtAccessTokenConverter jwtAccessTokenConverter() {
        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
        converter.setSigningKey("JWTKey@123");
        return converter;
    }

    @Override
    public void configure(AuthorizationServerSecurityConfigurer cfg) throws Exception {

        // Enable /oauth/token_key URL used by resource server to validate JWT tokens
        cfg.tokenKeyAccess("permitAll");

        // Enable /oauth/check_token URL
        cfg.checkTokenAccess("permitAll");

        // BCryptPasswordEncoder(8) is used for oauth_client_details.user_secret
        cfg.passwordEncoder(clientPasswordEncoder());
    }

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.jdbc(ds);
    }

    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {

        endpoints.accessTokenConverter(jwtAccessTokenConverter());
        endpoints.authenticationManager(authMgr);
        endpoints.userDetailsService(usrSvc);
    }
}
```

>Notice the JwtAccessTokenConverter ............................................TODO

**Configure User Security Authentication**

Let's create a class `UserSecurityConfig.java` to handle user authentication.

- **setEnableAuthorities(false)** disables the usage of authorities table and **setEnableGroups(true)** enables the usage of groups, group authorities and group members tables.  
- **BCryptPasswordEncoder** implements PasswordEncoder that uses the BCrypt strong hashing function. Clients can optionally supply a "strength" (a.k.a. log rounds in BCrypt) and a SecureRandom instance. The larger the strength parameter the more work will have to be done (exponentially) to hash the passwords. The value used in this example is 4 for user's password.

`com.codeaches.jwtoauth2server.UserSecurityConfig.java`

```java
@Configuration
public class UserSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    DataSource ds;

    @Override
    @Bean(BeanIds.USER_DETAILS_SERVICE)
    public UserDetailsService userDetailsServiceBean() throws Exception {
        return super.userDetailsServiceBean();
    }

    @Override
    @Bean(name = BeanIds.AUTHENTICATION_MANAGER)
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    @Bean("userPasswordEncoder")
    PasswordEncoder userPasswordEncoder() {
        return new BCryptPasswordEncoder(4);
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {

        // BCryptPasswordEncoder(4) is used for users.password column
        JdbcUserDetailsManagerConfigurer<AuthenticationManagerBuilder> cfg = auth.jdbcAuthentication()
                .passwordEncoder(userPasswordEncoder()).dataSource(ds);

        cfg.getUserDetailsService().setEnableGroups(true);
        cfg.getUserDetailsService().setEnableAuthorities(false);
    }
}
```

**Configure jwt-oauth2-server project to run on port 9051**

`src/main/resources/application.properties`

```properties
server.port=9051
```

**Start the JWT OAuth2 Server**

Run the `oauth2-server` application as `Spring Boot App` and make sure the server has started successfully on port `9051`

```java
TomcatWebServer  : Tomcat started on port(s): 9051 (http) with context path ''
DemoApplication  : Started DemoApplication in 12.233 seconds (JVM running for 14.419)
```

### **Test authorization server**

Now that we have the `jwtoauth2server` application up and running, let's test the application by submitting few POST calls.

**Get a token**

Let's get a token from OAuth2 Server for `kelly` using the URI `/oauth/token` and `grant_type=password`.

```sh
curl -X POST http://localhost:9051/oauth/token \
    --header "Authorization:Basic YXBwY2xpZW50OmFwcGNsaWVudEAxMjM=" \
    -d "grant_type=password" \
    -d "username=kelly" \
    -d "password=kelly@123"
```
```
{  
   "access_token":"<auth2_server_generated_kellys_access_token>",
   "token_type":"bearer",
   "refresh_token":"<auth2_server_generated_kellys_refresh_token>",
   "expires_in":24999,
   "scope":"read write",
   "jti":"f3afc8a6-7756-41b7-a152-a066e4ce6aca"
}
```

> `YXBwY2xpZW50OmFwcGNsaWVudEAxMjM=` is the Base 64 authorization version of client_id and client_secret.  

**Validate the access_token**

Let's validate the above retrieved **access_token** `<auth2_server_generated_kellys_access_token>` by making a call to OAuth2 Server using the URI `/oauth/check_token`

```sh
curl -X POST http://localhost:9051/oauth/check_token \
    -d "token=<auth2_server_generated_kellys_access_token>"
```
```
{
    "aud": [
        "carInventory"
    ],
    "user_name": "kelly",
    "scope": [
        "read",
        "write"
    ],
    "active": true,
    "exp": 1560110871,
    "authorities": [
        "INVENTORY_VIEW"
    ],
    "jti": "f3afc8a6-7756-41b7-a152-a066e4ce6aca",
    "client_id": "appclient"
}
```

**Get a new token by using earlier obtained refresh token**

Let's get a new token from OAuth2 Server by using the earlier obtained **refresh_token** `<auth2_server_generated_kellys_refresh_token>` using the URI **/oauth/token** and **grant_type=refresh_token**

```sh
curl -X POST http://localhost:9051/oauth/token \
    --header "Authorization:Basic YXBwY2xpZW50OmFwcGNsaWVudEAxMjM=" \
    -d "grant_type=refresh_token" \
    -d "refresh_token=<auth2_server_generated_kellys_refresh_token>"
```
```
{  
   "access_token":"<auth2_server_generated_kellys_new_access_token>",
   "token_type":"bearer",
   "refresh_token":"<auth2_server_generated_kellys_new_refresh_token>",
   "expires_in":24999,
   "scope":"read write",
   "jti":"8a7516cb-4af3-4a4d-ab1f-105e8d6ad1da"
}
```

> `YXBwY2xpZW50OmFwcGNsaWVudEAxMjM=` is the Base 64 authorization version of client_id and client_secret.  

### **Build resource server (Car Inventory Service)**

Building the bare bone Spring Resource server is simple - Create a spring boop application and annotate the main class with `@EnableResourceServer` annotation.

**Create a Spring Boot starter project using Spring Initializr**

Let's utilize the spring initializr starter tool to create the **Car Inventory Resource server**.

```sh
curl --request GET https://start.spring.io/starter.zip  \
     --data dependencies=web,cloud-security,cloud-oauth2 \
     --data language=java \
     --data javaVersion=12 \
     --data type=maven-project \
     --data groupId=com.codeaches \
     --data artifactId=jwt-car-inventory-service \
     --data bootVersion=2.1.5.RELEASE \
     --output jwt-car-inventory-service.zip
```

> The above command will give us a spring boot starter project. Import the project to your IDE.

**Configure Car Inventory Service project to run on port 8011**

`src/main/resources/application.properties`

```properties
server.port=8011
```

**Enable Resource Server Mechanism on Car Inventory Service**

Let's annotate DemoApplication.java with `@EnableResourceServer`. This annotation is used by spring internally to configure the Resource Server mechanism.

`com.codeaches.jwtcarinventoryservice.DemoApplication.java`

```java
@SpringBootApplication
@EnableResourceServer
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

**Add REST methods to Car Inventory Service**

Let's create a class `InventoryController.java` and configure REST methods **viewCars()** and **addCars()**

- **/viewCars** can be acessed by user who belongs to **INVENTORY_VIEW**.
- **/addCars** can be acessed by user who belongs to **INVENTORY_ADD**.

`com.codeaches.jwtcarinventoryservice.InventoryController.java`

```java
@RestController
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class InventoryController {

    @GetMapping("viewCars")
    @PreAuthorize("hasAuthority('INVENTORY_VIEW')")
    public Set<String> viewCars() {

        return cars;
    }

    @PostMapping("addCars")
    @PreAuthorize("hasAuthority('INVENTORY_ADD')")
    public String addCars(@RequestBody HashMap<String, String> payload) {

        cars.addAll(payload.values());
        return payload.values() + " was added to inventory successfully";
    }

    static Set<String> cars = new HashSet<>();
    static {
        cars.add("Toyota");
        cars.add("Benz");
    }
}
```

> Make sure to add **@EnableGlobalMethodSecurity(prePostEnabled = true)** to enable **@PreAuthorize** checks.

**Configure Car Inventory Service application with Client Credentials and JWT signing key**

Let's update **Car Inventory Service** application with client credentials for **appclient** and JWT signing key **JWTKey@123**
> Note that the client **appclient** is authorized to access **Car Inventory Service** resources in oauth_client_details table.

`src/main/resources/application.properties`

```properties
security.oauth2.client.client-id=appclient
security.oauth2.client.client-secret=appclient@123

security.oauth2.resource.id=petstore

security.oauth2.resource.jwt.key-value=JWTKey@123
```

> Note that the value of **security.oauth2.resource.jwt.key-value** should match the Signing Key provided in the OAuth2 Server. Please refer to **AuthServerConfig.java** in OAuth2 server.  
> Instead of **security.oauth2.resource.jwt.key-value**, we can also configure `security.oauth2.resource.jwt.key-uri` with `http://localhost:9051/oauth/token_key` for token validation.

**Start the Car Inventory Service**

Run the **Car Inventory Service** application as **Spring Boot App** and make sure the server has started successfully on port **8011**

```java
TomcatWebServer  : Tomcat started on port(s): 8011 (http) with context path ''
DemoApplication  : Started DemoApplication in 12.233 seconds (JVM running for 14.419)
```

### **Test resource server**

**Test `/viewCars` for a user who belongs to `INVENTORY_VIEW`**

> Both john and kelly have access to `/viewCars`

```sh
curl --request GET http://localhost:8011/viewCars \
     --header "Authorization:Bearer <auth2_server_generated_kellys_access_token>"
```
```
[
    "Benz",
    "Toyota"
]
```

> `<auth2_server_generated_kellys_access_token>` is the access_token obtained from OAuth2 Server for **Kelly**

**Test `/addCars` for a user who belongs to `INVENTORY_ADD`**

Only **John** has access to **/addCars**. Let's try to add a Car using John's access_token. The request succeeds.

```sh
curl --request POST http://localhost:8011/addCars \
     --data '{"car":"Nissan"}' \
     --header "Authorization:Bearer <auth2_server_generated_johns_access_token>" \
     --header "Content-Type: application/json"
```
```
[Nissan] was added to inventory successfully
```

> `<auth2_server_generated_johns_access_token>` is the access_token obtained from OAuth2 Server for **John**

**Test `/favouritePet` for a user user who `does NOT` belong to `AUTHORIZED_PETSTORE_ADMIN`**

> kelly does not belong to `AUTHORIZED_PETSTORE_ADMIN` and hence does not have access to `/favouritePet`

```sh
curl --request POST http://localhost:8011/addCars \
     --data '{"car":"Nissan"}' \
     --header "Authorization:Bearer <auth2_server_generated_kellys_access_token>" \
     --header "Content-Type: application/json"
```
```
{
    "error": "access_denied",
    "error_description": "Access is denied"
}
```

> `<auth2_server_generated_kellys_access_token>` is the access_token obtained from OAuth2 Server for **Kelly**

### **Summary**

This concludes the creation Spring Boot OAuth2 Authorization and Resource Servers with Java Web Token Store and BCrypt Password Encoder. I hope you like this aticle.

**Your feedback is always appreciated. Happy coding!**
